# Reactive main switch propagation

## Overview

The display pipeline no longer pulls rotary and button values from
`PeripheralManager._deprecated_get_main_switch`. Instead, the primary
switch exposes push-style updates via `BaseSwitch.subscribe_state` and
renderers cache the most recent `SwitchState` snapshot provided by the
callback. Consumers read from this cached state during `process` without
contacting the manager on every frame.

## Implementation

- `src/heart/peripheral/switch.py` defines the immutable `SwitchState`
  dataclass and implements subscription management inside
  `BaseSwitch`. The switch publishes snapshots whenever incoming events
  mutate its counters.
- `src/heart/peripheral/core/manager.py` surfaces
  `PeripheralManager.get_main_switch_state` and
  `PeripheralManager.subscribe_main_switch`, both delegating to the
  underlying switch so callers avoid the deprecated accessor.
- `src/heart/display/renderers/internal/switch_state.py` introduces
  `SwitchStateConsumer`, a mixin that subscribes once and caches the
  latest snapshot for renderers or controller classes.
- Display renderers such as
  `src/heart/display/renderers/text.py`, `life.py`,
  `spritesheet.py`, `spritesheet_random.py`, `multi_scene.py`, and
  `yolisten.py` extend the mixin and reuse the cached state inside their
  render loops.
- Navigation controllers in `src/heart/navigation.py` also adopt the
  mixin, keeping selector logic synchronized with switch events without
  ad hoc polling.

## Expected impact

The new flow removes repeated reads from the main switch on each frame
and centralizes state updates. Renderers react to the push-based
`SwitchState` snapshots, while simulated inputs generated by the
navigation layer still feed through `switch.update_due_to_data`, which
updates the cached snapshot immediately.
