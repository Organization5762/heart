# Reactive main switch propagation

## Overview

The display pipeline no longer pulls rotary and button values from
`PeripheralManager._deprecated_get_main_switch`. Instead, the primary
switch exposes push-style updates via `BaseSwitch.subscribe_state` and
renderers cache the most recent `SwitchState` snapshot provided by the
callback. Consumers read from this cached state during `process` without
contacting the manager on every frame.

## Implementation

- `src/heart/peripheral/switch.py` defines the immutable `SwitchState`
  dataclass and implements subscription management inside
  `BaseSwitch`. The switch publishes snapshots whenever incoming events
  mutate its counters.
- `src/heart/peripheral/core/manager.py` surfaces
  `PeripheralManager.get_main_switch_state` and
  `PeripheralManager.subscribe_main_switch`, both delegating to the
  underlying switch so callers avoid the deprecated accessor.
- `BaseRenderer.enable_switch_state_cache()` now registers a managed
  subscription that populates an internal cache while delegating update
  hooks to `on_switch_state`.
- Display renderers such as
  `src/heart/display/renderers/text.py`, `life.py`,
  `spritesheet.py`, `spritesheet_random.py`, `multi_scene.py`, and
  `yolisten.py` enable the cache and consume `get_switch_state()` during
  their render loops.
- Navigation controllers in `src/heart/navigation.py` call
  `enable_switch_state_cache()` to synchronize selector logic with
  switch events without ad hoc polling.

## Expected impact

The new flow removes repeated reads from the main switch on each frame
and centralizes state updates. Renderers react to the push-based
`SwitchState` snapshots, while simulated inputs generated by the
navigation layer still feed through `switch.update_due_to_data`, which
updates the cached snapshot immediately.
